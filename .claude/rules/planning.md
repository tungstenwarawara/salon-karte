# 計画・アーキテクチャルール

## 設計哲学
- 1画面1目的。1つのページに複数の主要タスクを詰め込まない
- 主要操作は3タップ以内で完了できること
- 選択肢は最小限。「どうすればいいか分からない」状態を作らない

## 機能追加ゲート（必ず問う）
- 「この機能がないと業務が回らないか？」→ NOなら追加しない
- 「既存画面に追加するより新画面が適切か？」
- 「ユーザーは説明なしで使い方がわかるか？」

## 確認済みの設計判断（変更しないこと）
1. **決済方法は4種のみ**: `cash`/`credit`/`ticket`/`service`
   - URL決済・振込・電子マネー等は対象外（個人サロンの実業務に不要）
2. **施術・物販・回数券は1画面内（カルテ新規作成）**
   - `records/new/page.tsx` に物販・回数券販売が `CollapsibleSection` で同居
   - 回数券消化はメニュー選択時に `paymentType: "ticket"` で紐づけ
3. **回数券の独立管理画面は不要**
   - 販売 → カルテ作成時にインライン
   - 消化 → カルテのメニュー支払タイプで連動
   - 一覧・残回数確認 → 顧客詳細ページ内の `CourseTicketSection`
   - 手動調整 → 顧客詳細ページ内で対応済み

## セッション開始ルール（必須）
1. **実態確認が先、計画は後**: `git log --oneline -10` と対象ソースの `wc -l` で現状を把握してから行動する
2. **計画ファイルを鵜呑みにしない**: `.claude/plans/` にファイルがあっても、ソースコードの実態と照合してから着手する
3. **ドキュメントの数値を信用しない**: 行数・件数などの静的記載は陳腐化している前提で、必ず実測する

## セッション完了ルール（必須）
1. **計画ファイルの削除**: 完了した計画の `.claude/plans/` ファイルは削除する（次セッションの誤認防止）
2. **コミットメッセージに次の予定を書かない**: git logは「やったこと」のみ。未来の予定はセッション中に判断する
3. **静的な進捗表を更新しない**: ルールファイルに行数や進捗率を書くと陳腐化する。実測コマンドで毎回確認する方式にする

## 教訓ログ
- 2026-02-19: 本番DBにマイグレーション未適用のままデプロイ → マージ前に適用確認必須
- 2026-02-19: Supabase dashboardから直接適用しローカルファイル不在 → 全マイグレーションはローカルファイルで管理
- 2026-02-19: RPC関数にSET search_path未設定 → 必ず `SECURITY INVOKER` + `SET search_path = public`
- 2026-02-20: records/new が1145行に膨張 → ファイルサイズ制限（ページ300行、コンポーネント200行）
- 2026-02-20: 不要な決済方法を計画に含めかけた → 実業務フローを確認してから計画
- 2026-02-21: CLAUDE.mdに古い行数を記載し続けた → 静的行数記載を廃止し実測コマンド方式に移行
- 2026-02-21: ソースレビューで `.select("..., description")` のカラム名誤りを見逃した（正しくは `memo`）→ レビュー時にselectカラム名をDBスキーマ（マイグレーションファイル）と照合必須。ビルドでは検出不可（文字列型のため）
- 2026-02-21: 計画ファイルが完了後も残り、次セッションが完了済みタスクを再実行しようとした → 計画完了時にファイル削除を必須化
- 2026-02-21: 顧客詳細ページの `.select("total_price, skin_condition")` が存在しないカラム名だった（正: purchasesの`total_price`を誤ってtreatment_recordsに指定、`skin_condition`→`skin_condition_before`）。同日の教訓（descriptionカラム誤り）と同じ問題が再発。Supabase SDKは存在しないカラムでもエラーを返さず空配列を返すため、3段階チェック（型・ビルド・実行時）全てをすり抜けた。→ コミット前にselect照合スクリプトを必ず実行する運用に変更
- 2026-02-21: 顧客詳細ページの全クエリ（treatment_records, appointments, purchases, course_tickets）に `.eq("salon_id", salon.id)` が欠落していた → salon_idフィルタの有無はルールに明記済みだったが守られなかった。コミット前チェックで自動検出する仕組みが必要
